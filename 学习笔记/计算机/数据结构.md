![[思维导图.webp|300]]
# 基本概念和术语
**数据(Data):**是对信息的一种符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。

**数据元素(Data Element):**是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项(Data Item)组成。数据项是数据的不可分割的最小单位。

**数据对象(Data Object):**是性质相同的数据元素的集合。是数据的一个子集。

**数据结构(Data Structure):**是相互之间存在一种或多种特定关系的数据元素的集合。

**数据的逻辑结构：**数据元素之间的相互关系称为逻辑结构。
1. 集合：结构中的数据元素除了同属于一种类型外，别无其它关系
2. 线性结构：结构中的数据元素之间存在一对一的关系
3. 树型结构：结构中的数据元素之间存在一对多的关系
4. 图状结构或网状结构：结构中的数据元素之间存在多对多的关系

**数据结构的形式定义**
数据结构的形式定义为：数据结构是一个二元组$Data_Structure =(D，S)$
D是数据元素的有限集，S是D上关系的有限集；
![[数据结构分类.png]]
## 抽象数据类型的表示与实现
**抽象数据类型(Abstract Data Type简称ADT)**是指一个数学模型以及定义在该模型上的一组操作。

抽象数据类型可用以下三元组表示$ADT =（D，S，P）$
D是数据对象，S是D上关系的有限集，P是对D的基本操作集。

## 算法和算法分析
**算法：**是对特定问题求解步骤的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。

算法具有以下五个特性：

$\color{red}\text{1.有穷性:}$ 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。

$\color{red}\text{2.确定性 :}$算法中每一条指令必须有确切的含义。不存在二义性。

$\color{red}\text{3.可行性 :}$一个算法是可行的。即算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。

$\color{red}\text{4.输入:}$一个算法$\color{red}\text{有零个或多个输入}$，这些输入取自于某个特定的对象集合。

$\color{red}\text{5.输出:}$一个算法$\color{red}\text{有一个或多个输出}$，这些输出是同输入有着某些特定关系的量。

算法设计的要求:

$\color{red}\text{1.正确性 }$算法应满足具体问题的需求。“正确”有四个层次：
(a)不含语法错误；(b)对几组输入正确；
(c)对精心设计的测试输入正确；(d)对一切合法输入正确

$\color{red}\text{2.可读性}$ 算法应该好读。以有利于阅读者对程序的理解。

$\color{red}\text{3.健状性 }$算法应具有容错处理。当输入非法数据时，算法应对其作出反应，而不是产生莫名其妙的输出结果。

$\color{red}\text{4.效率与存储量需求 }$效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般，这两者与问题的规模有关。

##
时间复杂度
最常用的六种多项式时间及其关系为：
O(1)<O($\mathbf{log}n$)<O(n)<O($n\mathbf{log}n$)<O($n^2$ )<O($n^3$ )

最常用的三种指数时间及其关系为：
O(2n )<O(n!)<O($n^n$ )


# 线性表
##  线性表的定义 (Definition of Linear List)

在线性表的定义中，我们主要关注两个方面：**数据元素**和它们之间的**关系**。

线性表（Linear List）是**零个或多个**数据元素的**有限序列**。

更正式地，它可以定义为具有相同数据类型的 $n$ 个（$n \ge 0$）元素的有限序列：

$$\text{List} = (a_1, a_2, \dots, a_{i-1}, a_i, a_{i+1}, \dots, a_n)$$

###  关键特征

- **有限性 (Finiteness):** 线性表的数据元素个数 $n$ 是有限的，即它不可能包含无限个元素。
- **序列性 (Sequence):** 线性表中的元素是**有序**的，它们在逻辑上是**依次排列**的。
- **一对一的关系 (One-to-One Relationship):**
    - **第一个元素** $a_1$ 没有前驱（predecessor）。
    - **最后一个元素** $a_n$ 没有后继（successor）。
    - **除了第一个和最后一个元素外，** 任何一个元素 $a_i$（其中 $1 < i < n$）都有且仅有一个**直接前驱** $a_{i-1}$ 和一个**直接后继** $a_{i+1}$。

### 术语解释

|**术语**|**描述**|
|---|---|
|**数据元素**|线性表中基本、不可分割的个体，可以是数字、字符、记录等。|
|**表长**|线性表中数据元素的总数，记为 $n$。当 $n=0$ 时，线性表称为**空表**。|
|**位序 (Position)**|元素在线性表中的位置，通常从 1 开始计数，如 $a_1$ 的位序是 1。|
|**前驱**|在 $a_i$ 之前的元素 $a_{i-1}$。|
|**后继**|在 $a_i$ 之后的元素 $a_{i+1}$。|

### 线性表的两种主要存储结构

虽然线性表的定义是**逻辑结构**，但在计算机中实现时，主要有两种物理存储结构：
1. **顺序存储结构 (Sequential Storage Structure):** 使用**一段地址连续的存储单元**依次存储线性表的数据元素。
    - **代表:** **数组 (Array)**。
    - **特点:** 随机存取效率高。
2. **链式存储结构 (Linked Storage Structure):** 通过在每个数据元素中附加一个或多个**指针域**，来存放其后继元素的存储地址。
    - **代表:** **单链表 (Singly Linked List)、双向链表 (Doubly Linked List)**。
    - **特点:** 插入和删除操作效率高。

## 基本操作（数组）
1.插入
```
void InsertList(&L,x,i)
//在线性表L中第i个位置插入元素x
{ if(i<1 || i>L.length+1){
cout<<“插入序号错误”<<endl;
return ERROR;}
if(L.length>=ListSize) 溢出处理；
else {
for(j=L.length-1;j>=i-1;j--)
//第i个元素（下标为i-1)开始
L.data[j+1]=L.data[j];//顺序后移
L.data[i-1]=x;
L.length++; }
}
```
2.删除
```
void deleteList(&L,i)//表L中删除第i个元素
{
if(i<1 || i>L.length){
cout<<“删除序号错”<<endl;
return ERROR;}
for(j=i; j<=L.length-1; j++)
L.data[j-1]=L.data[j];
L.length--;
}
```

3.合并
假设两个线性表LA和LB分别表示两个集合A和B，求新的集合A∪B
```
void Union(const SeqList& LA, const SeqList& LB, SeqList& LC) {
    // 假设 LC 已经初始化，且其 maxSize 足够容纳 LA.length + LB.length

    // 1. 将集合 A 中的所有元素复制到 LC 中
    for (int i = 0; i < LA.length; ++i) {
        ListInsert(LC, LA.data[i]);
    }

    // 2. 遍历集合 B 中的每个元素
    for (int i = 0; i < LB.length; ++i) {
        ElemType elementB = LB.data[i];
        
        // 3. 检查 elementB 是否已经在 LC 中（即 LA 中）
        if (!LocateElem(LC, elementB)) {
            // 4. 如果元素不存在，则将其添加到 LC 中
            ListInsert(LC, elementB);
        }
    }
}
```

## 基本操作（链表）
### 单链表
![[单链表.png]]
```
#include <iostream>
#include <cstdlib>
#include "assert.h"
​
template <class T>
class LNode
{
public:
  T data;
  LNode<T>* next;
};
​
template <class T>
class LinkList {
public:
  LinkList() { head = nullptr; }
  ~LinkList();
  bool clear();
  bool empty() { return head == nullptr; };
  int length();
  bool getElem(int i, T& t);
  int locateElem(const T& t);
  bool priorElem(const T& t_cur, T& t_pre);
  bool nextElem(const T& t_cur, T& t_next);
  bool insert(int i, T t);
  bool term(int i, T t);
  LNode<T>* reverse();
​
private:
  LNode<T>* head;
};
​
//清空函数
template <class T>
bool LinkList<T>::clear() {
  LNode<T> *p = head;
  while (head) {
    p = head;
    head = head->next;
    delete(p);
  }
  return true;
}
​
//析构函数
template <class T>
LinkList<T>::~LinkList() {
  clear();
}
​
//获取链表长度
template <class T>
int LinkList<T>::length() {
  LNode<T>* p = head;    //不能直接用head循环
  int len = 0;
  while (p != nullptr) {
    len++;
    p = p->next;
  }
  return len;
}
​
//获取指定位置元素
template <class T>
bool LinkList<T>::getElem(int i, T &t) {
  int j = 0;
  LNode<T>* p = head;
  while (j < i && p) {
    p = p->next;
    j++;
  }
  if (p == nullptr) return false;
  t = p->data;
  return true;
}
​
//查找元素位置
template <class T>
int LinkList<T>::locateElem(const T& t) {
  int loc = 0;
  LNode<T>* p = head;
  while (p->data!=t && p) {
    p = p->next;
    loc++;
  }
  if (p->data == t) return loc;
  else return -1;
}
​
//获取前驱节点
template <class T>
bool LinkList<T>::priorElem(const T& t_cur, T& t_pre) {
  LNode<T>* p = head;
  if (p->data == t_cur) return false;
  while (p->next->data != t_cur && p->next) {
    p = p->next;
  }
  if (p->next->data == t_cur) {
    t_pre = p->data;
    return true;
  }
   
  return false;
}
​
//获取后继节点
template <class T>
bool LinkList<T>::nextElem(const T& t_cur, T& t_next) {
  LNode<T>* p = head;
  if (head == nullptr || head->next == nullptr) return false;
  while (p->next != nullptr) {
    if (p->data == t_cur)
    {
      t_next = p->next->data;
      return true;
    }
    else
      p = p->next;
  }
  return false;
}
​
template <class T>
bool LinkList<T>::insert(int i, T t) {
  LNode<T>* p = head;
  LNode<T>* s = head;
  int loc = 0;
  if (i == 0) {
    s = (LNode<T>*)malloc(sizeof(LNode<T>));
    s->data = t;
    s->next = p;
    head = s;
    return true;
  }
  while (p && loc < i - 1) {
    p = p->next;
    loc++;
  }
  if (p == nullptr)
    return false;
  s = (LNode<T>*)malloc(sizeof(LNode<T>));
  s->data = t;
  s->next = p->next;
  p->next = s;
  return true;
}
​
//删除指定位置元素
template <class T>
bool LinkList<T>::term(int i, T t) {
​
  LNode<T>* p = head;
  int loc = 0;
  if (i == 0) {
    t = head->data;
    head = head->next;
    delete p;
    p = nullptr;
    return true;
  }
  while (p && loc < i - 1) {
    loc++;
    p = p->next;
  }
  if (p == nullptr)
    return false;
​
  LNode* s;
  s = p->next;
  p->next = p->next->next;
  t = s->data;
  delete s;
  s = NULL;
  return true;
}
​
//反转链表
template <class T>
LNode<T>* LinkList<T>::reverse() {
  if (head == nullptr || head->next == nullptr) return head;
  LNode<T> *p = head, *q = head->next, *r;
  head->next = nullptr;
  while (q) {
    r = q->next;
    q->next = p;
    p = q;
    q = r;
  }
  head = p;
  return head;
}
​
```
### 双链表
![[双链表.png]]
```text
#include <iostream>
#include <cstdlib>
#include "assert.h"
​
template <class T>
class DNode
{
public:
  DNode<T> *next;
  DNode<T> *prev;
  T data;
};
​
template <class T>
class List
{
public:
  List();//默认构造函数
  List(const List& ln);//拷贝构造函数
  ~List();//析构函数
  void add(T e);//向链表添加数据
  void remove(T index);//移除某个结点
  T find(int index);//查找结点
  bool empty();//判断是否为空
  int size();//链表长度
  void print();//显示链表
  void print_reverse();//链表反向显示
  void clear();//删除全部结点
private:
  DNode<T> *head;
  DNode<T> *tail;
  int length;
};
​
​
//默认构造函数
template <typename T>
List<T>::List()
{
  head = new DNode<T>;
  tail = new DNode<T>;
  head->next = tail;
  head->prev = nullptr;
  tail->next = nullptr;
  tail->prev = head;
  length = 0;
}
​
//拷贝构造函数
template <typename T>
List<T>::List(const List &ln)
{
  head = new DNode<T>;
  head->prev = nullptr;
  tail = new DNode<T>;
  head->next = tail;
  tail->prev = head;
  length = 0;
  DNode<T>* temp = ln.head;
  while (temp->next != ln.tail)
  {
    temp = temp->next;
    tail->data = temp->data;
    DNode<T> *p = new DNode<T>;
    p->prev = tail;
    tail->next = p;
    tail = p;
    length++;
  }
  tail->next = nullptr;
}
​
//析构函数
template <typename T>
List<T>::~List()
{
  if (length == 0)
  {
    delete head;
    delete tail;
    head = nullptr;
    tail = nullptr;
    return;
  }
  while (head->next != nullptr)
  {
    DNode<T> *temp = head;
    head = head->next;
    delete temp;
  }
  delete head;
  head = nullptr;
}
​
//向链表添加数据
template <typename T>
void List<T>::add(T e)
{
  DNode<T>* temp = this->tail;
  tail->data = e;
  tail->next = new DNode<T>;
  DNode<T> *p = tail;
  tail = tail->next;
  tail->prev = p;
  tail->next = nullptr;
  length++;
}
//查找结点
template <typename T>
T List<T>::find(int index)
{
  if (length == 0)
  {
    std::cout << "List is empty";
    return NULL;
  }
  if (index >= length)
  {
    std::cout << "Out of bounds";
    return NULL;
  }
  int x = 0;
  DNode<T> *p;
  p = head->next;
  while (p->next != nullptr && x++ != index)
  {
    p = p->next;
  }
​
  return p->data;
}
//删除结点
template <typename T>
void List<T>::remove(T index)
{
  if (length == 0)
  {
    std::cout << "List is empty";
    return;
  }
  DNode<T> *p = head;
  while (p->next != nullptr)
  {
    p = p->next;
    if (p->data == index)
    {
      DNode<T> *temp = p->prev;
      temp->next = p->next;
      p->next->prev = temp;
      delete p;
      length--;
      return;
    }
  }
}
//删除所有结点
template <typename T>
void List<T>::clear()
{
  if (length == 0)
  {
    return;
  }
  DNode<T> *p = head->next;
  while (p != tail)
  {
    DNode<T>* temp = p;
    p = p->next;
    delete temp;
  }
  head->next = tail;
  tail->prev = head;
  length = 0;
}
​
//判断是否为空
template <typename T>
bool List<T>::empty()
{
  if (length == 0)
  {
    return true;
  }
  else {
    return false;
  }
}
//链表长度
template <typename T>
int List<T>::size()
{
  return length;
}
//输出链表
template <typename T>
void List<T>::print()
{
  if (length == 0)
  {
    std::cout << "List is empty" << std::endl;
    return;
  }
  DNode<T> *p = head->next;
  while (p != tail)
  {
    std::cout << p->data << " ";
    p = p->next;
  }
  std::cout << std::endl;
}
//反向输出链表
template <typename T>
void List<T>::print_reverse()
{
  if (length == 0)return;
  DNode<T> *p = tail->prev;
  while (p != head)
  {
    std::cout << p->data << " ";
    p = p->prev;
  }
  std::cout << std::endl;
}
```

# 栈和队列 

栈和队列是**限定插入和删除只能在表的“端点”进行**的线性表 。它们是两种常用的数据类型 。
## 3.1 栈 (Stack)
![[栈.png|300]]
### 3.1.1 栈的定义和特性
- **定义**：栈是**限制在表的一端**进行插入和删除运算的线性表 。
- **术语**：
    - 进行插入、删除的一端称为**栈顶** (_Top_) 。
    - 另一端称为**栈底** (_Bottom_) 。
    - 表中没有元素时称为**空栈** 。
- **特性**：栈的修改遵循**后进先出** (Last In First Out, **LIFO**) 或**先进后出** (First In Last Out, **FILO**) 的原则 。
    - 若栈 $S=(a_1, a_2, ..., a_n)$，则 $a_1$ 为栈底元素， $a_n$ 为栈顶元素。退栈的第一个元素应为栈顶元素 。
### 抽象数据类型 (ADT) 栈
- **数据对象 $D$**：$D = \{ a_i \mid a_i \in ElemSet, i=1, 2, ..., n, n \ge 0 \}$ 。
- **数据关系 $R1$**：$R1=\{<a_{i-1}, a_i> \mid a_{i-1}, a_i \in D, i=2, ..., n\}$，约定 $a_n$ 端为栈顶，$a_1$ 端为栈底 。
- **基本操作**：
    - `InitStack(&S)`：构造一个空栈S 。
        
    - `DestroyStack(&S)`：销毁已存在的栈S 。
        
    - `StackEmpty(S)`：判断栈S是否为空 。
        
    - `ClearStack(&S)`：将栈S清为空栈 。
        
    - `StackLength(S)`：返回S的元素个数，即栈的长度 。
        
    - `GetTop(S, &e)`：用 $e$ 返回栈S的栈顶元素（栈S非空） 。
        
    - `Push(&S, e)`：插入元素 $e$ 为新的栈顶元素 。
        
    - `Pop(&S, &e)`：删除S的栈顶元素，并用 $e$ 返回其值 。
        
    - `StackTravers(S, visit())`：遍历栈 。
        

### 栈的表示和实现 
栈是线性表的特例，其存储结构对线性表也适用 。

| **存储结构** | **名称**                     | **实现方式** | **栈顶/栈底表示**                       | **进栈/退栈操作**                                                       |
| -------- | -------------------------- | -------- | --------------------------------- | ----------------------------------------------------------------- |
| **顺序存储** | **顺序栈** (Sequential Stack) | 数组       | 栈底固定；栈顶位置由**整型变量 `top` (栈顶指针)**指出 | `Push`: `*S.top++ = e;` (先赋值后加1) ；`Pop`: `e = *--S.top;` (先减1后取值) |
| **链式存储** | **链栈** (Linked Stack)      | 链表       | **栈顶指针**就是链表的**头指针** (`top`)      | 插入和删除操作仅限制在**链头位置**上进行                                            |

- **顺序栈的判满**：`S.top - S.base >= S.stacksize` 。
### 栈的应用举例 

由于栈具有后进先出的特性，使其成为程序设计中常用的工具 。

1. **数制转换 ：
    - 原理：十进制 $N$ 转换为 $d$ 进制，利用 $N=(N / d) \times d + N \bmod d$ 。
    - 方法：将 $N$ 连续除以 $d$，得到的**余数序列**逆序即为结果。利用栈将余数**先进后出**，实现逆序输出 。
2. **括号匹配的检验  ：
    - 思想：利用栈的 LIFO 特性 。
        - 遇到**左括弧**，则**进栈** 。
        - 遇到**右括弧**，检查栈是否为空；若不空且与栈顶元素**相匹配**，则**左括弧出栈** 。
        - 检验结束：若栈空，则匹配正确；若栈不空，则“左括弧”有余 。
3. **行编辑程序 ：
    - 利用栈作为输入缓冲区，允许用户在输入过程中进行差错更正 。
    - 字符处理规则：
        - 普通字符：`Push(S, ch)` 。
        - **退格符** (`#`)：`Pop(S, c)` (删除前一个字符) 。
        - **退行符** (`@`)：`ClearStack(S)` (清空当前行输入) 。
            
4. **迷宫求解 ** ：
    - 方法：通常用**穷举求解**的方法 。
        
    - 算法思想：
        - 若当前位置“可通”（未曾走到过的通道块），则**纳入路径（进栈）**，继续前进 。
        - 若当前位置“不可通”，则**后退**（从栈顶位置开始），换方向继续探索 。
        - 若四周“均无通路”，则将当前位置从路径中**删除出去（出栈）** 。

---
## 3.4 队列 (Queue)
![[队列.png]]
### 3.4.1 队列的定义和特性
- **定义**：队列也是一种运算受限的线性表，它**只允许在表的一端进行插入，而在另一端进行删除** 。
- **术语**：
    - 允许删除的一端称为**队头** (_front_) 。
    - 允许插入的一端称为**队尾** (_rear_) 。
    - 队列中没有元素时称为**空队列** 。
- **特性**：队列的修改遵循**先进先出** (First In First Out, **FIFO**) 的原则 。

### 抽象数据类型 (ADT) 队列
- **数据对象 $D$**：$D=\{ a_i \mid a_i \in ElemSet, i=1, 2, ..., n, n \ge 0 \}$ 。
- **数据关系 $R1$**：$R1=\{<a_{i-1}, a_i> \mid a_{i-1}, a_i \in D, i=2, ..., n\}$，约定 $a_1$ 端为队列头， $a_n$ 端为队列尾 。
- **基本操作**：
    - `InitQueue(&Q)`：构造一个空队列Q 。
        
    - `DestroyQueue(&Q)`：销毁已存在的队列Q 。
        
    - `QueueEmpty(Q)`：判断队列Q是否为空 。
        
    - `ClearQueue(&Q)`：将Q清为空队列 。
        
    - `QueueLength(Q)`：返回Q的元素个数，即队列的长度 。
        
    - `GetHead(Q, &e)`：用 $e$ 返回Q的队头元素（非空） 。
        
    - `EnQueue(&Q, e)`：插入元素 $e$ 为Q的新的队尾元素 。
        
    - `DeQueue(&Q, &e)`：删除Q的队头元素，并用 $e$ 返回其值（非空） 。
        
    - `QueueTravers(Q, visit())`：遍历队列 。
        

### 队列类型的实现

#### 1. 链队列 
- **结构**：采用链式存储，包含**队头指针 `front`** 和**队尾指针 `rear`** 。
- **空队列**：`Q.front` 和 `Q.rear` 均指向头结点 。
- **入队 (`EnQueue`)**：在**队尾**（`Q.rear` 所指结点之后）插入新结点 。
- **出队 (`DeQueue`)**：删除**队头**（`Q.front->next`）的结点 。
    - **特殊处理**：若删除后队列为空（`Q.rear == p`），需将 `Q.rear` 重新指向头结点 `Q.front` 。

#### 2. 循环队列 
- **结构**：采用顺序存储（向量空间），将向量空间想象为一个**首尾相接的圆环** 
- **指针**：`front` (队头指针，指向队头元素) 和 `rear` (队尾指针，指向队尾元素的**下一个位置**) 
- 操作：头尾指针的移动使用模运算进行循环意义下的加1：$$i = (i + 1) \bmod \text{MaxSize}$$
- **队空**：`Q.front == Q.rear` 。
- **队满**：
    - 在循环队列中，队空和队满时头尾指针均相等，**无法通过 `front == rear` 直接区分** 。
        
    - **常用解决方法**：
        1. 另设一个**布尔变量**区分空和满 。
        2. **少用一个元素的空间**，约定入队前，测试尾指针循环意义下加1后是否等于头指针。若相等，则认为队满 。
        3. 使用一个**计数器**记录队列中元素的总数（队列长度） 。

- **入队 (`EnQueue`)**：
    - 判断队满：`if ((Q.rear + 1) % MAXQSIZE == Q.front)` 。
        
    - 操作：`Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXQSIZE;` 。
        
- **出队 (`DeQueue`)**：
    - 判断队空：`if (Q.front == Q.rear)` 。
    - 操作：`e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXQSIZE;` 。

# 数组和广义表 

## 5.1 数组的定义

- **概念**：数组是唯一可供使用的数据类型，其特点是各元素具有统一的类型，且元素的下标一般具有固定的上界和下界 。多维数组是向量的推广 。
    
- **n维数组的抽象数据类型 (ADT Array)**：
    
    - **数据对象 $D$**：$D=\{a_{j_{1},j_{2},...,j_{n}}|j_{i}=0,...,b_{i}-1,i=1,2,..,n\}$ 。
        
    - **数据关系 $R$**：$R=\{R1,R2,...,Rn\}$，定义了元素之间的前后关系 。
        
- **二维数组的抽象数据类型 (ADT Array)**：
    
    - **数据对象 $D$**：$D=\{a_{ij}|0\le i\le b_{1}-1,0\le j\le b_{2}-1\}$ 。
        
    - **数据关系 $R$**：$R=\{ROW,COL\}$，定义了行关系 $ROW=\{<a_{i,j},a_{i+1,j}>\}$ 和列关系 $COL=\{<a_{i,j},a_{i,j+1}>\}$ 。
        
- **基本操作**：
    
    - `InitArray(&A, n, bound1, ..., boundn)`：构造数组A 。
        
    - `DestroyArray(&A)`：销毁数组A 。
        
    - `Value(A, &e, index1, ..., indexn)`：取值操作，将指定元素值赋给e 。
        
    - `Assign(&A, e, index1, ..., indexn)`：赋值操作，将e的值赋给指定元素 。
        

## 5.2 数组的顺序表示和实现

- **类型特点**：
    1. 只有**引用型操作**，没有加工型操作 。
    2. 数组是**多维结构**，但存储空间是**一维结构** 。
- **顺序映象方式 (存储方式)**：
    
    1. **行优先顺序 (Row-Major Order)**：以行序为主序，即低下标优先 。
        
        - 按行排列，第$i+1$个行向量紧接在第$i$个行向量后面 。
            
        - C/C++、PASCAL语言采用此方式 。
            
        - **多维推广**：先排最右的下标，从右到左，最后排最左下标 。
            
    2. **列优先顺序 (Column-Major Order)**：以列序为主序，即高下标优先 。
        
        - 按列向量排列，第$j+1$个列向量紧接在第$j$个列向量之后 。
            
        - FORTRAN语言采用此方式 。
            
        - **多维推广**：先排最左下标，从左向右，最后排最右下标 。
            
- **地址计算（随机存取结构）**：数组中任一元素可以在相同的时间内存取 。
    
    - n维数组A($c_1$:$d_1$, ..., $c_n$:$d_n$) 行优先存储地址计算公式：$$LOC(a_{i_1,i_2,\dots,i_n}) = V_0 + i_1 \times M_1 + i_2 \times M_2 + \dots + i_n \times M_n$$
        其中，$V_0$ 是基地址相关的常数，$M_k$ 是对应维的权值 。
        

## 5.3 矩阵的压缩存储

- **目的**：节省存储空间，只为非零元素分配存储空间 。
    
- **稀疏矩阵 (Sparse Matrix)**：
    
    - **稀疏因子 $\delta$**： $\frac{t}{m \times n}$  ，其中 $m \times n$ 是矩阵总元素数，$t$ 是非零元素个数 。
    - **定义**：通常认为 $\delta \le 0.05$ 的矩阵为稀疏矩阵 。
    
    - **压缩原则**：
    1) 尽可能少存或不存零值元素；
    2) 尽可能减少没有实际意义的运算；
    3) 操作方便（能快地找到元素） 。
    - **分类**：
        1. **特殊矩阵**：非零元分布有一定规则（如三角矩阵、对角矩阵） 。
        2. **随机稀疏矩阵**：非零元在矩阵中随机出现 。

### 5.3.1 特殊矩阵
- **对称矩阵**：$n$ 阶方阵A满足 $a_{ij}=a_{ji}$ 。
    - **压缩存储**：只存储上三角或下三角（包括主对角线）中的元素 。
    - **存储容量**：可用一个容量是 $\frac{(n+1)n}{2}$ 的一维数组存储 。
    - **矩阵元素与一维数组的对应关系**：$$k = \frac{i(i-1)}{2} + j - 1 \quad \text{（适用于下三角矩阵，当 } i \ge j \text{ 时）}$$

![[n阶对称阵与一维数组空间对应关系.png]]
- **三对角矩阵**：非零元素集中在以主对角线为中心的带状区域中，即除了主对角线和其相邻两侧对角线上的元素外，其余为零 。
    ![[三对角矩阵.png|300]]

### 5.3.2 随机稀疏矩阵的压缩存储方法

1. **三元组顺序表 (Triple Sequence List)**：
    - **表示**：一个三元组 $(i, j, a_{ij})$ 唯一确定一个非零元，存储了非零元所在的行$i$、列$j$及其值$a_{ij}$ 。
    - **转置运算**：
        
        - **基本思想**：按列号从小到大的顺序将矩阵M的非零元转置到T中 。
            
        - **快速转置算法 (Fast Transpose)**：时间复杂度更高效。
            
            - 利用两个辅助向量：`num[col]` 存储每列非零元个数；`pos[col]` 存储每列第一个非零元在转置矩阵 $T.data$ 中的起始位置 。
            - 计算公式：$$pos[1]=1$$$$pos[col]=pos[col-1]+num[col-1]$$ ($2\le col\le n$) 。
            - 通过一次扫描即可完成转置 。



# 树和二叉树
## 6.1 树的定义和基本术语
一、 树的定义 (递归定义)
1. 树是由 n(n≥0) 个结点组成的有限集合 。
2. 若 n=0，称为**空树** 。
3. 若 n>0，则：
    - 有一个特定的结点称为**根 (root)**，它只有直接后继，没有直接前驱 。
    - 除根以外的其它结点划分为 m(m≥0) 个互不相交的有限集合 T0​,T1​,…,Tm−1​，每个集合又是一棵树，称为根的**子树** 。
4. 树是一种重要的**非线性结构**，属于**递归结构** 。
![[树.png]]

二、 树的基本术语

| 术语               | 定义/描述                                 |
| ---------------- | ------------------------------------- |
| **结点**           | 数据元素加若干指向子树的分支 。                      |
| **结点的度**         | 结点拥有的**分支的个数** 。                      |
| **树的度**          | 树中所有结点的度的**最大值** 。                    |
| **叶子结点** (终端结点)  | 度为**零**的结点 。                          |
| **分支结点** (非终端结点) | 度**大于零**的结点 。                         |
| **双亲结点/孩子结点**    | 直接前驱为双亲，直接后继为孩子 。                     |
| **兄弟结点**         | 具有**相同双亲**的结点 。                       |
| **堂兄弟**          | 双亲是兄弟的结点 。                            |
| **祖先结点/子孙结点**    | 从根到该结点路径上的结点为祖先，以该结点为根的子树中的结点为子孙 。    |
| **路径/路径长度**      | 从根到该结点所经分支和结点构成路径，路径上的**分支数目**为路径长度 。 |
| **结点的层次**        | 根结点层次为1，其子树根结点的层次为 l+1 。              |
| **树的深度** (高度)    | 树中叶子结点所在的**最大层次** 。                   |


### 三、 树的分类
1. **有序树:** 子树之间存在确定的次序关系 。
2. **无序树:** 子树之间不存在确定的次序关系 。
3. **森林 (Forest):** 是 m(m≥0) 棵**互不相交**的树的集合 。

---

## 6.2 二叉树
一、 二叉树的定义 (递归定义)
1. 二叉树是由 n(n≥0) 个结点的有限集合构成 。
2. 此集合或者为**空集** 。
3. 或者由一个**根结点**以及两棵**互不相交的左、右子树**组成 。

二、 二叉树与树的区别
1. 二叉树是**有序树** 。
2. 即使结点只有一个孩子，也要区分它是**左孩子**还是**右孩子** 。

三、 特殊的二叉树
1. **满二叉树 (Full Binary Tree):** 深度为 k 且含有 2k−1 个结点的二叉树 。
2. **完全二叉树 (Complete Binary Tree):** 树中所含的 n 个结点和深度为 k 的满二叉树中编号为 1 至 n 的结点一一对应的二叉树 。

四、 二叉树的重要特性
1. **性质 1:** 在二叉树的第 i 层上至多有 2i−1 个结点 (i≥1) 。
    
2. **性质 2:** 深度为 k 的二叉树上至多含 2k−1 个结点 (k≥1) 。
    
3. **性质 3:** 对任何一棵二叉树，若它含有 $n_0$​ 个叶子结点、$n_2$ 个度为 2 的结点，则必有关系式：$$n_0=n_2+1$$

4. **性质 5 (完全二叉树编号关系):** 对含 n 个结点的完全二叉树编号：
    
    - 编号为 i 的结点的双亲编号为 ⌊i/2⌋ (i>1 时) 。
        
    - 其左孩子编号为 2i (若 2i≤n) 。
        
    - 其右孩子编号为 2i+1 (若 2i+1≤n) 。
        

---

### 6.3 遍历二叉树和线索二叉树

一、 二叉树遍历

遍历的目的是将非线性结构上的结点排列成线性序列 。

|遍历方法|访问次序 (L:左子树, D:根, R:右子树)|描述|应用示例|
|---|---|---|---|
|**先(根)序**|DLR|访问根 → 先序左子树 → 先序右子树 。|前缀表达式 (波兰式)|
|**中(根)序**|LDR|中序左子树 → 访问根 → 中序右子树 。|中缀表达式|
|**后(根)序**|LRD|后序左子树 → 后序右子树 → 访问根 。|后缀表达式 (逆波兰式)|
|**层次遍历**|自上而下，自左至右 。|通常使用队列实现 。|-|


- **非递归遍历:** 可利用**栈**实现 (如中序遍历) 。
    
- **复杂度:** 时间复杂度为 O(n) ，空间复杂度 (栈的容量) 等于树的深度，最坏情况为 O(n) 。
    
- **应用:** 统计叶子结点个数 (先序)、求二叉树深度 (后序)、复制二叉树 (后序) 等 。
    

二、 由遍历序列确定二叉树

1. **能唯一确定:** 已知**先序 + 中序**序列，或**后序 + 中序**序列 。
    
2. **不一定能唯一确定:** 仅知先序序列，或已知**先序 + 后序**序列 。
    

三、 线索二叉树 (Threaded Binary Tree)

1. **线索:** 在二叉链表存储结构中，利用空闲的 `lchild` 和 `rchild` 指针，指向该结点在遍历序列中的**前驱**和**后继**，这些指针称为“线索” 。
    
2. **线索二叉树:** 加上线索的二叉树 。
    
3. **线索链表存储结构:**
    - 结点增加两个标志域 `LTag` 和 `RTag`，用于区分指针域是**指向孩子** (Link) 还是**指向前驱/后继** (Thread) 。
        
    - 若左子树不空，`lchild` 指向左子树，`LTag = Link` 。否则，`lchild` 指向**前驱**，`LTag = Thread` 。
        
    - 若右子树不空，`rchild` 指向右子树，`RTag = Link` 。否则，`rchild` 指向**后继**，`RTag = Thread` 。
        
4. **作用:** 简化了遍历算法，方便直接找到某结点的前驱和后继 。
    

---

### 6.4 树和森林

一、 树的存储结构

1. **双亲表示法:**
    
    - 用一组连续空间存储结点。结点包含数据域和**双亲位置域** (`parent`) 。
        
    - **特点:** 找双亲容易，找孩子难 。
        
2. **孩子表示法 (多重链表):**
    
    - 每个结点有多个指针域，分别指向其子树的根 。
        
3. **孩子-兄弟表示法 (二叉链表):**
    
    - 结点包含数据域、**第一个孩子指针** (`firstchild`)、**下一个兄弟指针** (`nextsibling`) 。
        
    - **特点:** 操作容易，但破坏了树的层次 。
        

二、 森林与二叉树的转换

1. **转换规则:**
    
    - 森林 F=(T1​,T2​,…,Tn​) 转换成的二叉树 B 。
        
    - T1​ 的根结点作为 B 的**根结点** 。
        
    - T1​ 的子树森林作为 B 的**左子树** 。
        
    - 除 T1​ 外的其余树构成的森林 (T2​,T3​,…,Tn​) 作为 B 的**右子树** 。
        

三、 树和森林的遍历

1. **树的遍历:**
    
    - **先根(次序)遍历:** 访问根 → 依次先根遍历各子树 。
        
    - **后根(次序)遍历:** 依次后根遍历各子树 → 访问根 。
        
    - **层次遍历:** 自上而下，自左至右 。
        
2. **森林的遍历 (对应二叉树遍历):**
    
    - **先序遍历:** 访问第一棵树的根 → 先序遍历第一棵树的子树森林 → 先序遍历其余树构成的森林 。**等同于**对森林中的每棵树依次进行**先根遍历** 。
        
    - **后序遍历:** 后序遍历第一棵树的子树森林 → 访问第一棵树的根 → 后序遍历其余树构成的森林 。**等同于**对森林中的每棵树依次进行**后根遍历** 。
        

---

### 6.6 赫(哈)夫曼树及其应用
![[哈夫曼树.png]]
一、 最优树与哈夫曼树

1. **结点的带权路径长度:** 从根到该结点的路径长度 li​ 与该结点权值 wi​ 的乘积 (wi​×li​) 。
    
2. **树的带权路径长度 (WPL):** 树中所有**叶子结点**的带权路径长度之和 。
    
3. **最优树:** 在所有含 n 个叶子结点、并带相同权值的 m 叉树中，其 **WPL 取最小值**的树 。
    
4. **哈夫曼树 (Huffman Tree):** WPL 最小的**二叉树**，又称最优二叉树 。$$\text{WPL} = \sum_{i=1}^n w_i \times l_i$$
    

二、 哈夫曼树的构造算法 (哈夫曼方法)

1. 将 n 个权值构成 n 棵只有一个根结点的二叉树，得到森林 F 。
    
2. 从 F 中选取**根结点权值最小**的两棵树，作为新二叉树的左右子树 。新根的权值等于两子树根权值之和 。
    
3. 从 F 中**删除**这两棵树，**加入**新生成的树 。
    
4. 重复步骤 2 和 3，直到 F 中只剩一棵树为止，这棵树即为哈夫曼树 。
    
5. **时间复杂度:** O(nlogn) 。
    

三、 哈夫曼编码 (Huffman Coding)

1. 以字符的频度为权值构造哈夫曼树 。
    
2. 将所有**右分枝标记 1**，所有**左分枝标记 0** 。
    
3. 从根到叶子结点的路径上的标记序列即为对应字符的编码 。
![[Huffman树算法及时间复杂度分析.png]]

#  图 (Graph) 

## 7.1 图的定义和术语
- **图的结构定义**：图是由一个**顶点集** $V$ 和一个**弧集** $R$ 构成的抽象数据结构，表示为 $Graph=(V, R)$ 。
    
    - $V$: 顶点集，元素为数据对象 $x \in DataObject$ 。
        
    - $R$: 弧集，表示数据关系 $VR=\{\langle v,w \rangle | v, w \in V, P(v,w)\}$ 。
        
- **有向图 (Directed Graph)**：由顶点集和有方向的**弧**集构成的图。$\langle v,w \rangle$ 中，$v$ 为弧尾，$w$ 为弧头 。
    
- **无向图 (Undirected Graph)**：若弧集 $VR$ 中，$\langle v,w \rangle \in VR$ 必有 $\langle w,v \rangle \in VR$，则称 $(v,w)$ 为顶点 $v$ 和 $w$ 之间的一条**边**，由顶点集和边集构成的图称为无向图。
    
- **网 (Net) / 加权图 (Weighted Graph)**：弧（或边）带权的图分别称作有向网或无向网 。
    
- **子图 (Subgraph)**：图 $G'=(V', \{VR'\})$ 满足 $V' \subseteq V, VR' \subseteq VR$，则 $G'$ 是 $G$ 的子图 。
    
- **完全图 (Complete Graph)**：
    
    - 无向完全图：含有 $e=n(n-1)/2$ 条边（$n$ 为顶点数） 。
        
    - 有向完全图：含有 $e=n(n-1)$ 条弧 。
        
- **稀疏图 (Sparse Graph) 与 稠密图 (Dense Graph)**：若边或弧的个数 $e < n \log_2 n$，则称作稀疏图，否则称作稠密图 。
- **邻接点 (Adjacent Vertices)**：若顶点 $v$ 和 $w$ 之间存在一条边，则互为邻接点 。
- **度 (Degree)**：
    - **无向图**：和顶点 $v$ 关联的边的数目定义为顶点的度 。
        
    - **有向图**：
        - **出度 (Out-degree, OD)**：以顶点 $v$ 为弧尾的弧的数目 。
            
        - **入度 (In-degree, ID)**：以顶点 $v$ 为弧头的弧的数目 。
            
        - **总度 (TD)** = 出度 (OD) + 入度 (ID) 。
            
- **路径 (Path)**：顶点序列 $\{u=V_{i,0}, V_{i,1}, ..., V_{i,m}=w\}$，且相邻顶点之间存在弧/边。
    
- **路径长度 (Path Length)**：路径上边的数目 。
    
- **简单路径 (Simple Path)**：序列中顶点不重复出现的路径 。
    
- **简单回路 (Simple Circuit)**：序列中第一个顶点和最后一个顶点相同，其余顶点不重复出现的路径 。
    
- **连通图 (Connected Graph)**：无向图中任意两个顶点之间都有路径相通 。
    
- **连通分量 (Connected Component)**：无向图的极大连通子图 。
    
- **强连通图 (Strongly Connected Graph)**：有向图中任意两个顶点之间都存在一条有向路径 。
    
- **强连通分量 (Strongly Connected Component)**：有向图的各个强连通子图 。
    
- **生成树 (Spanning Tree)**：一个连通图的极小连通子图，包含所有 $n$ 个顶点和 $n-1$ 条边 。
    
- **生成森林 (Spanning Forest)**：非连通图的各个连通分量的生成树的集合 。
    

## 图的基本操作

- **结构的建立和销毁**：`CreatGraph(&G, V, VR)`、`DestroyGraph(&G)` 。
    
- **对顶点的访问操作**：`LocateVex(G, u)`、`GetVex(G, v)`、`PutVex(&G, v, value)` 。
    
- **对邻接点的操作**：`FirstAdjVex(G, v)`（返回第一个邻接点）、`NextAdjVex(G, v, w)`（返回相对于 $w$ 的下一个邻接点） 。
    
- **插入或删除顶点**：`InsertVex(&G, v)`、`DeleteVex(&G, v)` 。
    
- **插入和删除弧**：`InsertArc(&G, v, w)`、`DeleteArc(&G, v, w)`（无向图需处理对称弧） 。
    
- **遍历**：`DFSTraverse`（深度优先搜索）、`BFSTraverse`（广度优先搜索） 。
    

## 7.2 图的存储表示

1. **邻接矩阵 (Adjacency Matrix)**：
    - 使用二维数组存储弧/边信息。$A_{ij}$ 表示 $\langle i,j \rangle$ 上的关系（1/0 或权值） 。
    - 有向图的邻接矩阵是非对称矩阵 。
    - 网（加权图）使用加权邻接矩阵 。
![[图的邻接矩阵.png]]
![[有向图的邻接矩阵为非对称矩阵.png]]
![[图的加权邻接矩阵.png]]
2. **邻接表 (Adjacency List)**：
    - 包含**顶点结点**（存储顶点信息和指向第一条依附该顶点的弧的指针）和**弧的结点**（存储该弧指向的顶点位置、指向下一条弧的指针、以及弧相关信息） 。
![[图的邻接表.png]]
    - 有向图的邻接表中不易找到指向该顶点的弧 。
- ![[有向图的邻接表.png]]
        
3. **十字链表 (Orthogonal List)** (适用于有向图)：
    - **弧的结点 (ArcBox)** 包含 `tailvex`（弧尾位置）、`headvex`（弧头位置）、`hlink`（指向下一个有相同弧头的结点）、`tlink`（指向下一个有相同弧尾的结点） 。
        
    - **顶点结点 (VexNode)** 包含 `data`、`firstin`（指向第一条入弧）、`firstout`（指向第一条出弧） 。

![[有向图的十字链表表示.png]]

## 7.3 图的遍历

- **定义**：从图中某个顶点出发游历图，访遍图中其余顶点，且每个顶点仅被访问一次 。
- **深度优先搜索 (DFS)**：
    - 类似于树的先根遍历 。
    - **使用栈**来保存已访问的顶点（或其邻接点）。
    - `DFSTraverse` 算法通过调用 `DFS` 处理非连通图，调用次数即为连通分量数。
`void DFSTraverse(Graph G,Status (*Visit)(int v)) {`
`// 对图 G 作深度优先遍历。`
`VisitFunc = Visit;`
`for (v=0; v<G.vexnum; ++v)`
	`visited[v] = FALSE; // 访问标志数组初始化`
`for (v=0; v<G.vexnum; ++v)`
	`if (!visited[v]) DFS(G, v);`
	`// 对尚未访问的顶点调用DFS`
`}`
- **广度优先搜索 (BFS)**：
    - 从起始点开始，依次访问其所有未被访问的邻接点，然后按访问次序依次访问它们的邻接点，直至所有连通顶点被访问 。
    - **使用队列**来保存已访问过的顶点 。
`void BFSTraverse(Graph G,Status (*Visit)(int v)){`
`for (v=0; v<G.vexnum; ++v)`
	`visited[v] = FALSE; //初始化访问标志`
`InitQueue(Q);// 置空的辅助队列Q`
`for ( v=0; v<G.vexnum; ++v )`
	`if ( !visited[v]) {`
	`// v 尚未访问`
	`}`
`} // BFSTraverse`
- **DFS/BFS 生成树**：每次遍历所经过的边同图的顶点构成的子图 。
![[DFS生成树和BFS生成树.png]]
## 7.4 图的连通性问题
### 7.4.3 最小生成树 (MST)
- **问题**：在带权连通图中，选取 $n-1$ 条边（不构成回路），使“权值之和”为最小 。
- **MST 性质**：若 $(u,v)$ 是一条连接集合 $U$ 和 $V-U$ 的代价最小的边，则必存在一棵包括边 $(u,v)$ 在内的最小代价生成树 。

- **普里姆算法 (Prim's Algorithm)**：
    - **思想**：从图中任意一个顶点开始，逐步添加新的顶点和连接边。每次选择一条权值最小的边，该边连接**已在生成树上**的顶点和**未在生成树上**的顶点 。
    - **特点**：当前形成的集合 $T$ **始终是一棵树** 。
    - **时间复杂度**：$O(n^2)$，适用于**稠密图** 。
`void MiniSpanTree_P(MGraph G, VertexType u) {`
`//用普里姆算法从顶点u出发构造网G的最小生成树`
`k = LocateVex ( G, u );`
`for ( j=0; j<G.vexnum; ++j ) // 辅助数组初始化`
	`if (j!=k)`
		`closedge[j] = { u, G.arcs[k][j].adj };`
`closedge[k].lowcost = 0; // 初始，U＝{u}`
`for (i=0; i<G.vexnum; ++i) {`
`继续向生成树上添加顶点; }`
`k = minimum(closedge)；`
`// 求出加入生成树的下一个顶点(k)`
`printf(closedge[k].adjvex, G.vexs[k]);`
`// 输出生成树上一条边`
`closedge[k].lowcost = 0; // 第k顶点并入U集`
`for (j=0; j<G.vexnum; ++j)`
`//修改其它顶点的最小边`
`if (G.arcs[k][j].adj < closedge[j].lowcost)`
	`closedge[j] = { G.vexs[k], G.arcs[k][j].adj };`
	
- **克鲁斯卡尔算法 (Kruskal's Algorithm)**：
    - **思想**：按权值从小到大的顺序选择边，若添加该边不形成回路，则加入生成树，直至加入 $n-1$ 条边 。
    - **特点**：当前形成的集合 $T$ **始终是一个森林** 。
    - **时间复杂度**：$O(e \log_2 e)$，适用于**稀疏图** 。
`构造非连通图 ST=( V,{ } );`
`k = i = 0; // k 计选中的边数`
`while (k<n-1) {`
	`++i;`
`检查边集 E 中第 i 条权值最小的边(u,v);`
`若(u,v)加入ST后不使ST中产生回路，`
`则 输出边(u,v); 且 k++;`
`}`

| 算法名   | Prim's Algorithm | Kruskal's Algorithm    |
| ----- | ---------------- | ---------------------- |
| 时间复杂度 | $O(n^2)$         | $O(e \log_2 e)$        |
| 适应范围  | 稠密图              | 稀疏图                    |
| 特点    | 当前形成的集合T始终是一棵树   | 当前形成的集合T除了最后的结果外，是一个森林 |


## 7.5 有向无环图及其应用

- **有向无环图 (DAG)**：一个无环的有向图 。
![[DAG.png]]
### 7.5.1 拓扑排序 (Topological Sorting)
- **目的**：将有向图中的顶点按照次序关系排成一个线性序列 。
- **算法**：
    1. 计算各顶点的入度 。
    2. 将所有入度为零的顶点入栈 。
    3. **循环**：出栈一个顶点 $v$，输出 $v$，并将 $v$ 的所有邻接点 $w$ 的入度减一 。
    4. 如果 $w$ 的入度减为零，则将 $w$ 入栈 。
    5. 如果输出的顶点数小于总顶点数 $n$，则图中有回路 。

### 7.5.2 关键路径 (Critical Path)
- **AOE 网 (Activity On Edge)**：带权的有向无环图。顶点表示**事件**，弧表示**活动**，权表示活动**持续时间** 。
    - **源点**：入度为 0 的顶点（工程开始点） 。
    - **汇点**：出度为 0 的顶点（工程结束点） 。
    - **工程完成时间**：源点到汇点的**最长路径**长度 。
- **关键活动 (Critical Activity)**：活动余量为 0 的活动 。
- **关键路径 (Critical Path)**：由关键活动构成的路径（即源点到汇点的最长路径） 。
- **时间计算**：
    
    - **事件 $j$ 的最早发生时间 $ve(j)$**：$ve(\text{源点}) = 0$。$ve(j) = \max \{ve(k) + dut(\langle k,j \rangle)\}$ (在拓扑有序序列上计算) 。
        
    - **事件 $j$ 的最迟发生时间 $vl(j)$**：$vl(\text{汇点}) = ve(\text{汇点})$。$vl(j) = \min \{vl(k) - dut(\langle j,k \rangle)\}$ (在拓扑逆序序列上计算) 。
        
    - **活动 $\langle j,k \rangle$ 的最早开始时间 $ee(i)$**：$ee(i) = ve(j)$ 。
        
    - **活动 $\langle j,k \rangle$ 的最迟开始时间 $el(i)$**：$el(i) = vl(k) - dut(\langle j,k \rangle)$ 。
        
    - **活动余量**：$el(i) - ee(i)$ 。
        

## 7.6 最短路径

- **问题**：求图中两点之间边上权值之和最小的一条路径。
    
    - **单源最短路径**：求从某个源点到其余各点的最短路径 。
        
    - **每一对顶点之间的最短路径** 。
        
- **迪杰斯特拉算法 (Dijkstra's Algorithm)**：用于求解**单源最短路径**（带权非负） 。
    
    - **思想**：按最短路径长度**递增次序**产生最短路径 。
        
    - **步骤**：
        1. 设置集合 $U$，存放已求得最短路径的顶点（初始只含源点 $v_0$） 。
        2. 设置辅助数组 $Dist[k]$，存储当前从源点到其余各顶点 $k$ 的最短路径长度（初始为 $\langle v_0, k \rangle$ 的权值或 $\infty$） 。
        3. 迭代：从 $V-U$ 中选择一个 $u$ 使 $Dist[u]$ 最小，并将 $u$ 加入 $U$ 。
        4. 修改 $V-U$ 中顶点的 $Dist$ 值：$$Dist[k] = \min\{Dist[k], Dist[u] + G.arcs[u][k]\}$$
            （如果经过 $u$ 到 $k$ 的路径更短，则更新 $Dist[k]$） 。
        5. 重复直至所有顶点都在 $U$ 中。

# 查找

## 查找表的基本概念与分类

| **概念**   | **定义**                            |
| -------- | --------------------------------- |
| **查找表**  | 由同一类型的数据元素（或记录）构成的集合 。            |
| **关键字**  | 数据元素中某个数据项的值，用以标识一个数据元素 。         |
| **主关键字** | 可识别唯一的一个记录 。                      |
| **次关键字** | 能识别若干记录 。                         |
| **查找**   | 根据给定值，在查找表中确定其关键字等于给定值的数据元素（或记录）。 |

**查找表的分类：** 

1. **静态查找表：** 仅作查询和检索操作的查找表 。
    
2. **动态查找表：** 在查询后，还需要进行插入或删除操作的查找表 。
## 9.1 静态查找表
#### 1. 顺序表的查找 (Sequential Search)
- **特点：** 对表没有特殊要求 。
- **平均查找长度（ASL）公式 (等概率查找 $P_i = 1/n$):** $$ASL_{ss} = \sum_{i=1}^{n} P_i C_i = \sum_{i=1}^{n} \frac{1}{n} (n-i+1) = \frac{n+1}{2}$$
`int Search_Seq(SSTable ST,KeyType key) {`
	`// 在顺序表ST中顺序查找其关键字等于`
	`// key的数据元素。若找到，则函数值为`
	`// 该元素在表中的位置，否则为0。`
	`ST.elem[0].key = key;// “哨兵”`
	`for (i=ST.length; ST.elem[i].key!=key; --i);`
	`// 从后往前找`
	`return i;// 找不到时，i为0`
`} // Search_Seq`
#### 2. 有序表的查找 (Ordered Table Search) - 折半查找 (Binary Search)
- **特点：** 要求表有序 。
- **查找公式：** $mid = \lfloor (low+high)/2 \rfloor$ 。
- **时间性能：** 查找速度最好，时间复杂度为 $O(\log n)$ 。
`int Search_Bin ( SSTable ST, KeyType key ) {`
	`low = 1; high = ST.length; // 置区间初值`
	`while (low <= high) {`
		`mid = (low + high) / 2;`
		`if （EQ (key , ST.elem[mid].key) )`
			`return mid; // 找到待查元素`
		`else if ( LT (key , ST.elem[mid].key) )`   
			`high = mid - 1; // 继续在前半区间进行查找`
		`else low = mid + 1; // 继续在后半区间进行查找`
	`}`
	`return 0; // 顺序表中不存在待查元素`
`} // Search_Bin`
#### 3. 索引顺序表的查找 (Indexed Sequential Search) - 分块查找 (Block Search)
- **特点：** 数据块之间在物理上可不连续，需要增加索引数据的空间。
- **平均查找长度（ASL）公式** (设表长 $n$，平均分成 $b$ 块，每块含 $s$ 个记录， $n=b \cdot s$):
    - 用顺序查找确定所在块 (查找索引表 + 块内查找):$$ASL_{bs} = L_b + L_w \approx \frac{b+1}{2} + \frac{s+1}{2}$$
        当 $s \approx \sqrt{n}$ 时，ASL 最小 。
    - 用折半查找确定所在块 (查找索引表 + 块内查找):$$ASL_{bs} \approx \log_2(b+1) + \frac{s+1}{2}$$
![[索引表查找.png|500]]
## 9.2 动态查找表

### 1. 二叉排序树 (Binary Search Tree, BST)
`struct BSTNode {`
    `int data;`
    `BSTNode *lchild, *rchild;`
    `// 构造函数简化节点创建`
    `BSTNode(int val) : data(val), lchild(nullptr), rchild(nullptr) {}`
`};`
`// 使用引用传递指针 T`
`void insert(BSTNode* &T, int key) {`
    `if (T == nullptr) {`
        `// 找到插入位置，直接修改原指针`
        `T = new BSTNode(key);`
    `} else if (key < T->data) {`
        `insert(T->lchild, key); // 递归左子树`
    `} else if (key > T->data) {`
        `insert(T->rchild, key); // 递归右子树`
    `}`
    `// 如果 key == T->data，则默认不插入重复值`
`}`
`BSTNode* createBST(const std::vector<int>& nums) {`
    `BSTNode* root = nullptr;`
    `for (int x : nums) {`
        `insert(root, x);`
    `}`
    `return root;`
`}`
- **定义**:二叉排序树或者是一棵空树；或者是具有如下特性的二叉树：
	（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值；
	（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值；
	（3）它的左、右子树也都分别是二叉排序树。
- **查找:** 若查找不成功，返回指针 $p$ 指向查找路径上访问的最后一个结点 。
- 迭代实现
`// 在二叉排序树 T 中查找关键字 key`
`BSTNode* BST_Search(BSTNode* T, int key) {`
    `while (T != nullptr && key != T->data) {`
        `if (key < T->data) {`
            `T = T->lchild; // 关键字小，往左走`
        `} else {`
            `T = T->rchild; // 关键字大，往右走`
        `}`
    `}`
    `return T; // 如果没找到，最后 T 会变成 nullptr`
`}`
 - 递归实现
`BSTNode* BST_Search_Recursive(BSTNode* T, int key) {`
    `if (T == nullptr || T->data == key) {`
        `return T;`
    `}`
    `if (key < T->data) {`
        `return BST_Search_Recursive(T->lchild, key);`
    `} else {`
        `return BST_Search_Recursive(T->rchild, key);`
    `}`
`}`
- **删除：** 删除结点 $p$ 时，若 $p$ 的左右子树均非空，则用**左子树中值最大的结点**（或右子树中值最小的结点）来代替 $p$ 。
`// 辅助函数：查找最小值节点（用于找后继）`
`BSTNode* findMin(BSTNode* T) {`
    `while (T->lchild != nullptr) T = T->lchild;`
    `return T;`
`}`

`// 删除函数`
`void BST_Delete(BSTNode* &T, int key) {`
    `if (T == nullptr) return; // 没找到该节点`
    `if (key < T->data) {`
        `BST_Delete(T->lchild, key); // 往左找`
    `} else if (key > T->data) {`
        `BST_Delete(T->rchild, key); // 往右找`
    `} else {`
        `// 找到了目标节点 T`
        
        `// 情况 1 & 2：无孩子或只有一个孩子`
        `if (T->lchild == nullptr) {`
            `BSTNode* temp = T;`
            `T = T->rchild; // 右孩子顶替（若右也为空，T就变成了nullptr）`
            `delete temp;`
        `} else if (T->rchild == nullptr) {`
            `BSTNode* temp = T;`
            `T = T->lchild; // 左孩子顶替`
            `delete temp;`
        `}` 
        `// 情况 3：有两个孩子`
        `else {`
            `// 找到右子树的后继节点（最小值）`
            `BSTNode* successor = findMin(T->rchild);`
            `// 用后继节点的值覆盖当前节点的值`
            `T->data = successor->data;`
            `// 在右子树中删除那个多余的后继节点`
            `BST_Delete(T->rchild, successor->data);`
        `}`
    `}`
`}`
### 2. 平衡二叉树 (Balanced Binary Tree, AVL Tree)
- **定义**：树中每个结点的左、右子树深度之差的绝对值不大于1的二叉排序树
![[二叉树与非平衡二叉树.png|500]]
- **平衡旋转术**：
 ![[平衡旋转术（左调整）.png||500]]
 ![[LR情况.png||500]]
- **最小结点数 $N_h$ (深度为 $h$):** $N_h = N_{h-1} + N_{h-2} + 1$ 。
- 最大深度 $h_n$ (含 $n$ 个结点):
$$h_n = \log_{\phi}(\sqrt{5}(n+1)) - 2$$
  
    (其中 $\phi =\frac{1+\sqrt{5}}{2}$) 。
- **查找时间复杂度：** $O(\log n)$ (在等查找概率前提下) 。
### 3. B-树 (B-Tree) 和 B+树 (B+ Tree)
#### B-树
- **定义**：B-树是一种 $\color{red}\text{平衡 的}$ 多路 查找 树.
- **阶数**：一棵 $m$ 阶B-树（B-tree）的每个**内部节点**（非叶子节点）最多可以有 $m$ 个子节点（子树指针）
![[B-树.png||500]]
- **特性**：
1. 多叉树特性：在 m 阶的B-树上，每个非终端结点可能含有：
	 n 个关键字 $K_i$ （1≤ i≤n） n<m;
	 n+1 个指向子树的指针 $A_i$ （0≤i≤n）
2. 平衡树特性：
	 树中所有叶子结点均不带信息，且在树中的同一层次上；
	根结点或为叶子结点，或至少含有两棵子树；
	其余所有非叶结点均至少含有$\lceil{m/2}\rceil$棵子树,至多含有 m 棵子树；
- **性质小结**：
- 一棵m阶B-树，或为空树，或为满足下列特性的m叉树：(m≥3)
(1)根结点只有1个，关键字字数的范围$[1,m-1]$，分支数量范围$[2,m]$；
(2)除根以外的非叶结点，每个结点包含分支数范围$[\lceil{m/2}\rceil,m]$，即关键字字数的范围是$[ \lceil{m/2}\rceil -1,m-1]$，其中$\lceil{m/2}\rceil$表示取大于$m/2$的最小整数；
- C语言描述：
`typedef struct BTNode {`
	`int keynum; // 结点中关键字个数，结点大小`
	`struct BTNode *parent;`
		`// 指向双亲结点的指针`
	`KeyType key[m+1]; // 关键字（0号单元不用）`
	`struct BTNode *ptr[m+1]; // 子树指针向量`
	`Record *recptr[m+1]; // 记录指针向量`
`} BTNode, *BTree; // B树结点和B树的类型`
- **B-树 (m 阶) 查找：**
    - **查找访问结点数 (含 $N$ 个关键字):** 不超过 $\log_{\lceil m/2 \rceil} ((N+1)/2) + 1$ 。
- **B+树 (B+ Tree) 结构特点：** 
![[B+树.png||500]]
    - 所有叶子结点彼此相链接，构成一个**有序链表** 。
    - 每个非叶结点中的关键字 $K_i$ 是其相应指针 $A_i$ 所指子树中关键字的**最大值** 。
    - 所有叶子结点包含所有关键字 。

### 9.3 哈希查找表 (Hash Searching)
#### 哈希表
##### 哈希函数
以 $f(key)$ 作为关键字为 $key$ 的记录在表中的位置，通常称这个函数 $f(key)$为哈希函数。
**构造哈希函数的方法：**
1. **直接定址法：**
	哈希函数为关键字的线性函数$H(key) = key$或者$H(key) = a \times key + b$
	此法仅适合于：$地址集合的大小 = = 关键字集合的大小$
2. **数字分析法**
	假设关键字集合中的每个关键字都是由 s 位数字组成$(u_1, u_2, …, u_s)$，分析关键字集中的全体， 并从中提取分布均匀的若干位或它们的组合作为地址。
	此方法仅适合于：能预先估计出全体关键字的每一位上各种数字出现的频度。
	![[数字分析法.png||500]]

3. **平方取中法**
	以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同时平方值的中间各位又能受到整个关键字中各位的影响。
	此方法适合于:关键字中的每一位都有某些数字重复出现频度很高的现象。
4. **折叠法**
	将关键字分割成若干部分，然后取它们的叠加和为哈希地址。有两种叠加处理的方法：移位叠加和间界叠加。
	此方法适合于:关键字的数字位数特别多。
![[折叠法.png||500]]
5. **除留取余法**
设定哈希函数为:$H(key) = key MOD p$其中， p≤m (表长) 并且p 应为不大于 m 的素数或是不含 20 以下的质因子
6. **随机数法**

**处理冲突的方法**
1. **开放地址法**
为产生冲突的地址 $H(key)$ 求得一个地址序列：$H_0, H_1, H_2, …, H_s  1≤ s≤m-1$其中：$H_0 = H(key)$
$H_i = ( H(key) + d_i ) MOD m$
$i=1, 2, …, s$
$d_i$有三种取法
	 1) 线性探测再散列$di = c\times i$最简单的情况 $c=1$
    2) 平方探测再散列$d_i = 1^2, -1^2, -2^2 , …,$
     3) 随机探测再散列$d_i$ 是一组伪随机数列
2. 链地址法
##### 哈希表的定义：
根据设定的哈希函数 $H(key)$ 和所选中的处理冲突的方法，将一组关键字映象到一个有限的、地址连续的地址集 (区间) 上，并以关键字在地址集中的“象”作为相应记录在表中的存储位置，如此构造所得的查找表称之为“哈希表”。
- **影响哈希表查找 ASL 的因素：** 
    1. 选用的哈希函数。
    2. 选用的处理冲突的方法。
    3. 哈希表饱和的程度，装载因子 $\alpha = n/m$ 值的大小（$n$—记录数，$m$—表的长度）。

---

# 内部排序
### 10.1 概述
- **排序：** 将一组“无序”的记录序列调整为“有序”的记录序列 。
- **稳定与不稳定：** 关键字相等的任意两个记录，若排序前后相对位置保持不变，则为**稳定**的排序方法，否则为**不稳定**的 。
- **内部排序：** 整个排序过程不需要访问外存便能完成 。
- **内部排序方法的分类：** 
    1. **插入类**
    2. **交换类**
    3. **选择类**
    4. **归并类**
    5. **其它方法**
### 10.2 插入排序 (Insertion Sort)

| **方法**     | **核心思想**                                    | **关键改进点**            |
| ---------- | ------------------------------------------- | -------------------- |
| **折半插入排序** | 在有序序列中用**折半查找**确定插入位置，减少比较次数 。              | 减少比较次数。              |
| **希尔排序**   | 通过**增量 $\text{dk}$** (步长)进行分组，对每组进行直接插入排序 。 | 使得记录可以跳跃式地移动，减少移动次数。 |
#### 1.直接插入排序
利用 “顺序查找”实现“在中$R[1..i-1]$查找$R[i]$的插入位置”
**算法要点：**利用$R[0]$为哨兵，从后往前查找
`void InsertionSort ( SqList &L ) {`
`// 对顺序表 L 作直接插入排序。`
`for ( i=2; i<=L.length; ++i )`
	`if (L.r[i].key < L.r[i-1].key) {//<,需排序r[i]`
		`L.r[0] = L.r[i]; // 复制为监视哨`
		`for ( j=i-1; L.r[0].key < L.r[j].key; -- j )`
			`L.r[j+1] = L.r[j];// 记录后移`
		`L.r[j+1] = L.r[0]`
	`}`
`}`
#### 2.折半插入排序
`void BInsertSort (int* r,int n){` 
	`int i,low,high,m;`
	`int x;`
	`int j;`
	`for ( i = 1; i<=n-1 ; ++i ){`
		`x= r[i]; low = 0 ; high = i-1 ;`
		`while ( low <= high ){`
			`m = (low+high)/2;`
			`if ( x< r[m]) high = m -1 ;`
			`else low = m + 1;`
		`}`
		`for ( j=i-1; j>=high+1; --j ) r[j+1] = r[j];`
		`r[high+1] = x;`
	`}`
`} // BInsertSort`
#### 3.希尔排序$O(n^2)$
希尔排序的过程是：
1. **选择初始增量 $d_k$**：首先选取一个较大的增量 $d_k$。
2. **分组**：将待排序序列中的所有元素按增量 $d_k$ 分割成 $d_k$ 个子序列。例如，如果数组索引从 $0$ 开始，那么索引为 $i, i+d_k, i+2d_k, \dots$ 的元素组成一个子序列（其中 $0 \le i < d_k$）。
3. **子序列排序**：对每个子序列独立地进行**插入排序**。
4. **减小增量**：选择一个更小的增量 $d_{k-1}$（$d_{k-1} < d_k$），重复步骤 2 和 3。
5. **最终排序**：重复上述过程，**直至增量减少为 $d_0 = 1$**。当增量为 $1$ 时，整个序列被视为一个子序列，进行最后一次插入排序。此时，因为经过前面大增量的排序，序列已经接近有序，所以最后一步的插入排序效率非常高。
// 希尔排序函数
`void shellSort(vector<int>& arr) {`
    `int n = arr.size();`
    `// 1. 设置初始增量（gap）。初始增量通常取数组长度的一半`
    `for (int gap = n / 2; gap > 0; gap /= 2) {`
        `// 2. 对每个子序列进行插入排序`
        `// i 从 gap 开始，遍历所有子序列的第二个元素及之后的所有元素`
        `for (int i = gap; i < n; i++) {`
            `// temp 存储当前待插入的元素`
            `int temp = arr[i];`
            `// j 用于找到 arr[i] 应该插入的位置。`
            `// 这里的移动步长是 gap，而不是 1`
            `int j;`
            `// 3. 改进的插入排序：在当前的子序列中，`
            `// 比较 arr[j - gap] 和 temp，如果 arr[j - gap] 更大，则将其后移`
            `for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {`
                `arr[j] = arr[j - gap];`
            `}`
            `// 4. 将 temp 插入到正确的位置`
            `arr[j] = temp;`
        `}`
    `}`
`}`
### 10.3 快速排序 (Quick Sort)

- **分类：** 交换类 。
- **核心操作：** $\text{Partition}$（划分）。
- **基本原理：** 选择一个**枢轴 (pivotkey)**，一趟划分将序列分为两部分：关键字均不大于枢轴的记录在前，关键字均不小于枢轴的记录在后 。
#### 1.起泡排序$O(n^2)$
`void BubbleSort(){`
			`int n=size();`
			`for(int j=n-1;j>=1;j--){`
				`for(int i=0;i<j;i++){`
					`int temp=0;`
					`if(a[i]>a[i+1]){`
						`temp=a[i];`
						`a[i]=a[i+1];`
						`a[i+1]=temp;`
					`}`
				`}`
			`}`
		`}`
#### 2.快速排序$O(n \log n)$
**目标：**找一个记录，以它的关键字作为“枢轴”，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。
`int Partition(int low, int high) {`
    	`// 1. 选取基准元素 (Pivot)，这里选择最左边的元素`
    	`int pivot = a[low];` 
    	`int i = low;`
    	`int j = high;`
    	`while (i < j) {`
        	`// 2. 右侧扫描：j 向左移动，直到找到一个小于 pivot 的元素`
        	`while (i < j && a[j] >= pivot) {`
            	`j--;`
        	`}`
        	`// 将小的元素 A[j] 挪到 i 的位置`
        	`if (i < j) {`
            	`a[i] = a[j];`
            	`i++; // i 向前移动一位`
        	`}`
        	`// 3. 左侧扫描：i 向右移动，直到找到一个大于 pivot 的元素`
        	`while (i < j && a[i] <= pivot) {`
            	`i++;`
        	`}`
        	`// 将大的元素 A[i] 挪到 j 的位置`
        	`if (i < j) {`
            	`a[j] = a[i];`
            	`j--; // j 向后移动一位`
        	`}`
    	`}`
    	`// 4. 基准归位：i 和 j 相遇的位置就是 pivot 的最终位置`
    	`a[i] = pivot;`
    	`return i; // 返回基准元素最终的索引`
	`}`
	
	`// 递归函数：对子数组 [low, high] 进行快速排序`
	`void QuickSortHelper(int low, int high) {`
    	`if (low < high) { // 确保子数组至少有两个元素`
        	`// 1. 划分：进行一趟排序，获得基准元素的最终位置`
        	`int pivotIndex = Partition(low, high);`
        	`// 2. 递归：对左侧子数组进行排序`
        	`QuickSortHelper(low, pivotIndex - 1);`
        	`// 3. 递归：对右侧子数组进行排序`
        	`QuickSortHelper(pivotIndex + 1, high);`
    	`}`
	`}`
	`// 外部调用函数`
	`void QuickSort() {`
    	`QuickSortHelper(0, size() - 1);`
	`}`
快速排序的时间复杂度为$O(n\log n)$
### 10.4 选择排序 (Selection Sort)
#### 1. 简单选择排序 (Simple Selection Sort)
- **核心思想：** 第 $i$ 趟从无序区 $R[i..n]$ 中**选择**关键字最小的记录，与 $R[i]$ 交换 。
- **比较次数总计：**$$\sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2}$$
`void SelectSort(){`
		`int n=size();`
		`int i,j,k;`
		`int x;`
		`for(int i=0;i<n-1;i++){`
			`k=i;`
			`for(j=i+1;j<n;j++){`
				`if(a[j]<a[k]){`
					`k=j;`
				`}`
			`}`
			`if(k!=i){`
				`x=a[k];`
				`a[k]=a[i];`
				`a[i]=x;`
			`}`
		`}`
	`}`
#### 2. 堆排序 (Heap Sort)
- **核心思想：** 利用**堆**（Heap）数据结构进行排序 。
- **堆的定义 (以大顶堆为例):** 根结点的值比两个儿子的值都大 。
- **数组索引关系 ($r[0]$到$r[n-1]$):** 
    - $i$ 的左孩子: $i \times 2 + 1$
    - $i$ 的右孩子: $i \times 2 + 2$

### 10.5 归并排序 (Merge Sort)$O(n \log n)$

- **分类：** 归并类 。
    
- **核心思想：** 通过**归并**两个或两个以上的记录有序子序列，逐步增加有序序列的长度 。
    ![[归并排序.png|500]]

### 10.6 基数排序 (Radix Sort)
- **分类：** 其它方法 。
- **核心思想：** 将数据看成由 $t$ 位组成 。
    
- **步骤（共 $t$ 次）：** 
    1. **分配 (Distribution):** 根据右起第 $j$ 位数字，将数放入相应的桶 ($\text{B}_0 \dots \text{B}_9$) 中 。
    2. **收集 (Collection):** 按 $\text{B}_0 \dots \text{B}_9$ 的顺序进行收集 。
基数排序的时间复杂度通常表示为：

$$O(d \cdot (n + b))$$

其中：

- **$n$：** 待排序元素的个数（数据量）。
    
- **$d$：** 待排序数字的**最大位数**（Digits）。这决定了需要进行多少轮（趟）排序。
    
- **$b$：** 基数（Base），即使用的**桶的数量**。例如，如果按十进制的个位、十位、百位排序，则 $b=10$。
        

### 10.7 各种内部排序方法的比较讨论

- **时间与空间的关系：** 
    
    - 若降低空间复杂度，往往会增大时间复杂度。
        
    - 若增加空间复杂度，往往可以减小时间复杂度。
        
    - 在算法中，**时间资源**通常认为比空间资源更为宝贵 。
简单选择排序、堆排序和希尔排序是**不稳定的排序方法**


